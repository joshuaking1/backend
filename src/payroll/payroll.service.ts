import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreatePayrollDto } from './dto/create-payroll.dto';
import { parseISO } from 'date-fns';

@Injectable()
export class PayrollService {
  constructor(private prisma: PrismaService) {}

  /**
   * Generates a full payroll run for a specific branch and date range.
   * This is a transactional operation that calculates commissions and creates payslips.
   */
  async generatePayroll(dto: CreatePayrollDto, organizationId: string) {
    const { startDate: startDateStr, endDate: endDateStr, branchId } = dto;
    const startDate = parseISO(startDateStr);
    const endDate = parseISO(endDateStr);

    // --- Start of Transaction ---
    return this.prisma.$transaction(async (tx) => {
      // 1. Fetch all staff members of the specified branch who have a salary set.
      const staffInBranch = await tx.user.findMany({
        where: {
          branchId,
          staffProfile: {
            baseSalary: { not: null },
          },
        },
        include: {
          staffProfile: {
            include: {
              commissionRule: true,
            },
          },
        },
      });

      if (staffInBranch.length === 0) {
        throw new BadRequestException('No staff with salaries found in this branch.');
      }
      
      const organization = await tx.organization.findUnique({ where: { id: organizationId } });
      if (!organization) {
        throw new NotFoundException('Organization not found.');
      }

      // 2. Create the master Payroll record.
      const payrollRun = await tx.payroll.create({
        data: {
          startDate,
          endDate,
          branchId,
          organizationId,
          status: 'PROCESSING',
          notes: dto.notes,
        },
      });

      // 3. Process each employee individually.
      for (const employee of staffInBranch) {
        if (!employee.staffProfile) continue; // Type guard

        // a. Calculate Total Revenue Generated by this employee
        const sales = await tx.sale.findMany({
          where: {
            branchId,
            organizationId,
            createdAt: { gte: startDate, lte: endDate },
            OR: [
              { appointment: { artistId: employee.id } },
              { items: { some: { artistId: employee.id } } },
            ],
          },
          include: {
            items: true,
            appointment: true, // Include appointment to check artistId
          },
        });

        let totalRevenue = 0;
        sales.forEach(sale => {
          // If the sale is linked to an appointment by this artist, all items count towards their revenue.
          if (sale.appointment && sale.appointment.artistId === employee.id) {
            sale.items.forEach(item => {
              totalRevenue += item.priceAtTimeOfSale;
            });
          } else {
            // Otherwise, only count items specifically credited to the artist (e.g., product sales).
            sale.items.forEach(item => {
              if (item.artistId === employee.id) {
                totalRevenue += item.priceAtTimeOfSale;
              }
            });
          }
        });

        // b. Calculate Commission based on their rule
        let totalCommission = 0;
        const rule = employee.staffProfile.commissionRule;
        if (rule && rule.tiers) {
          const tiers = rule.tiers as { threshold: number; rate: number }[];
          // Sort tiers by threshold descending to apply the highest applicable rate
          tiers.sort((a, b) => b.threshold - a.threshold);

          for (const tier of tiers) {
            if (totalRevenue >= tier.threshold) {
              totalCommission = totalRevenue * tier.rate;
              break; // Stop after applying the first matching tier
            }
          }
        }
        
        // c. Calculate Net Pay
        const baseSalary = employee.staffProfile.baseSalary || 0;
        const bonuses = 0; // Placeholder for future implementation
        const deductions = 0; // Placeholder
        const netPay = baseSalary + totalCommission + bonuses - deductions;

        // d. Create the individual Payslip
        await tx.payslip.create({
          data: {
            baseSalary,
            totalCommission,
            bonuses,
            deductions,
            netPay,
            // TODO: The 'currency' should be stored on the Organization model.
            currency: (organization as any).currency || 'USD',
            employeeId: employee.id,
            payrollId: payrollRun.id,
          },
        });
      }

      // 4. Finalize the payroll run
      const finalPayroll = await tx.payroll.update({
        where: { id: payrollRun.id },
        data: { status: 'COMPLETED' },
      });

      return this.findOneWithPayslips(finalPayroll.id, tx);
    });
    // --- End of Transaction ---
  }

  findAllForOrg(organizationId: string) {
    return this.prisma.payroll.findMany({
      where: { organizationId },
      orderBy: { createdAt: 'desc' },
      include: { branch: true },
    });
  }

  async findOneWithPayslips(id: string, tx?: any) {
    const prisma = tx || this.prisma; // Use transaction client if available
    const payroll = await prisma.payroll.findUnique({
      where: { id },
      include: {
        branch: true,
        payslips: {
          include: {
            employee: { select: { firstName: true, lastName: true, email: true } },
          },
        },
      },
    });
    if (!payroll) throw new NotFoundException('Payroll run not found.');
    return payroll;
  }

  async findPayslipById(payslipId: string, organizationId: string) {
    const payslip = await this.prisma.payslip.findFirst({
      where: {
        id: payslipId,
        payroll: {
          organizationId,
        },
      },
      include: {
        employee: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        payroll: {
          include: {
            branch: true,
          },
        },
      },
    });

    if (!payslip) {
      throw new NotFoundException('Payslip not found.');
    }

    return payslip;
  }
}